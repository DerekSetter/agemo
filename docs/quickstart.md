# Quickstart

Interacting with **agemo** will always start with specifying a structured coalescent model as well as defining the branchtypes you want to distinguish. Once a StructuredCoalescentModel and a BranchTypeCounter have been genererated you can generate the Laplace transformed distribution of coalescence times.

## specify model

:::{todo}
Create StructuredCoalescentModel() object
:::

Currently, the available models are limited to structured coalescent models with uni-directional migration and/or population splits.


## sample configuration

The sample configuration should be a list of lists containing the label (**string**) for each sample within each population. Note that ancestral populations not containing any lineages at the time of sampling need to be represented as empty lists.


## specify branchtypes to distinguish

To generate the Laplace transform we need a mapping that maps all possible combinations of the sample labels to one of the branchtypes you want to distinguish. 
Each unique branchtype will be associated to a unique integer between 0 and the number of possible branchtypes. Either you can let the BranchTypeCounter take care of this, by specifying whether you want the mapping to retain root and/or phase information. Or you can proivde your own mapping using the branchtypedict option (see API).

If root is False (default), each subset of sampled lineages and its complement will be mapped to the same branchtype.

If phase is False (default), we can no longer make a distinction between any of the lineages within a single population. Phrased differently, we proceed as if all sampled lineages within a single population carry the same label.

:::{todo}
Make sure that when phase=False we check whether all samples from a single pop carry the same label.
:::

:::{todo}
Check, can a branchtype mapping be provided that is completely custom, and does not follow any rules.
:::

## generate Laplace transform

You are now set to instantiate a GFMatrixObject. From there we can use the `.make_gf` method to generate the Laplace transform. The result is a list of lists as well as an equation_array. The list contains all paths through the coalescent state space graph, with each sublist representing a single path. Index $i$ within a sublist points at equation_array[$i$] which contains the coefficients representing equation $i$. 

Build the equations in conventional form: `.gflib.equations_from_matrix`.

:::{note}
In case a discrete event was included, the equations generated by `.equations_from_matrix` still require taking an inverse Laplace transform with respect to the dummy variable representing the discrete event. This can be done using `.inverse.inverse_laplace_single_event()`.
:::

:::{todo}
Should be replaced by: agemo.GFMatrixObject(BranchTypeCounter, Structured Coalescent Model)
:::


## Evaluating the Laplace transform


eq_graph_array, eq_array, to_invert, eq_matrix = GFMatrixObject.equations_graph()
should this be another object?

:::{todo}
Decide whether result of equations_graph() method should be an object or not.
:::

### compute probabilities for bSFS
bsfs, see section on bSFS 
requires MutationTypeCounter
agemo.MutationTypeCounter(BranchtTypeCounter)
requires gfEvaluatorObj
takes care of inverse laplace with respect to a single discrete event

agemo.gfEvaluator(GFMatrixObj, MutationTypeCounter)